---
title: "Wheat"
#author:
output:
  #rmdformats::html_clean:
  rmdformats::downcute:
    downcute_theme: "chaos"
    use_bookdown: false
    self_contained: true
    thumbnails: true
    lightbox: true
    highlight: tango
    gallery: true
    toc_depth: 3
    code_folding: show
    css: css/custom.css
knit:
  (function(inputFile, encoding) { rmarkdown::render(inputFile, encoding =
  encoding, output_dir = "html") })
---

# Genomic project to investigate  the genetic basis of complex traits in Wheat (*T. aestivum*).

```{r}
rm(list = ls())
```

## Introduction

## Durum wheat (*Triticum turgidum* subsp. *durum*)

Data:
Dell'Acqua, Matteo (2022). Characterization data for the EtNAM population and Ethiopian durum wheat landraces diversity panel [Dataset]. Dryad. https://doi.org/10.5061/dryad.w6m905qrv form the orginal research article https://onlinelibrary.wiley.com/doi/10.1111/pbi.12538


Here we deal with data stored in the .Rdagst data format, great!

In the README_file.txt of the data repository we ahve the folllowing description:

>The file "*diversity.panel.data.gp.Rdata*" contains molecular and phenotypic data
relative to the Ethiopian durum wheat diversity panel used in this study.
The Rdata file contains serveral R objects:
>
>- **info**, passport data for the accessions included in the study
>- **geno**, containing genotypic data scored on 90K markers on the wheat array
>- **snp.pos**, containing estimated genomic positions of the 90K markers
>- **met**, containing agronomic characterization data
>- **farm**, containing participatory variety selection data
>
>The file "*etnam.data.gp.Rdata*" contains molecular and phenotypic data
relative to the EtNAM population used in this study.
The Rdata file contains serveral R objects:
>
>- **infonam**, passport data for the accessions included in the study
>- **infofound**, passport data for the parental lines of the EtNAM
>- **genonam**, containing genotypic data scored on 13K markers on the wheat array
>- **snp.pos.nam**, containing estimated genomic positions of the 90K markers
>- **metnam**, containing agronomic characterization data
>- **farmnam**, containing participatory variety selection data

```{r, echo = FALSE}
library(tidyverse)
```
```{r}
data_et <- load("Data/Triticum-durum/etnam.data.gp.Rdata")
data_et
```

```{r}
data <- load("Data/Triticum-durum/diversity.panel.data.gp.Rdata")
data

# agronomic characterization data
met_data <- met
met_data %>% as_tibble()

# participatory variety selection data
farm_data <- farm
farm %>% as_tibble()

# genotypic data scored on 90K markers on the wheat array
geno_data <- geno
geno %>%
  as_tibble(rownames = "row_n")

# estimated genomic positions of the 90K markers
snp_fpos_data <- snp.pos
snp_pos_data %>%
  as_tibble() %>%
  select(rs., alleles, chrom, pos, strand) #  %>% na.omit()

# passport data for the accessions included in the study
info_data <- info
info_data %>%
  rename(
    "code" = "ID",
    "ID" = "DNA_CODE"
  ) %>%
  as_tibble()
```

## Exploratory data analysis
### Agronomic data
```{r}
met_data %>% head()
```
ID = identification
DB = days to booting (d)
DF = days to flowering (d)
DM = days to maturity (d)
PH = plant height (cm)
NET = number of effective tillers per plant (n)
SPL = spike length (cm)
SPS = number of seeds per spike (n)
BM = biomass (t/ha)
GY = grain yeld (t/ha)
TGW = thousand grain weight (g)

##### Correlation Matrix:
```{r}
unique_ids <- make.unique(met_data$ID)

met_data_uniq <- met_data

rownames(met_data_uniq) <- unique_ids
head(met_data_uniq)

eda_met <- met_data %>%
  select(DB:ncol(met_data_uniq))

head(eda_met)
summary(eda_met)
nrow(eda_met)

eda_met <- na.omit(eda_met)
head(eda_met)

eda_met_corr <- cor(eda_met)
head(eda_met_corr)

# easy with corrplot, or...
require(corrplot)
corrplot(eda_met_corr, method = "color", type = "lower", order = "hclust", tl.col = "black", tl.srt = 90)

# melt the correlation matrix in a table
require(reshape2)
corr_tbl <- eda_met_corr %>%
  melt() %>% # alternatively use pivot_longer()
  as_tibble()

corr_tbl %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_continuous(name = "Pearson \n correlation") +
  labs(x = "", y = "") +
  theme(aspect.ratio = 1)

# split upper and lower triangles
{
  get_lower_tri <- function(eda_met_corr) {
    eda_met_corr[upper.tri(eda_met_corr)] <- NA
    return(eda_met_corr)
  }

  get_upper_tri <- function(eda_met_corr) {
    eda_met_corr[lower.tri(eda_met_corr)] <- NA
    return(eda_met_corr)
  }
}

tri_up <- get_upper_tri(eda_met_corr)
tri_down <- get_lower_tri(eda_met_corr)

# hierarchical clustering for

reorder_cor <- function(eda_met_corr){
  dd <- as.dist((1 - eda_met_corr) / 2)
  hc <- hclust(dd)
  eda_met_corr <- eda_met_corr[hc$order, hc$order]
}

eda_met_corr <- reorder_cor(eda_met_corr)
tri_down <- get_lower_tri(eda_met_corr)

melt_tri_down <- melt(tri_down, na.rm = TRUE) %>%
  filter(Var1 != Var2)

cor_plot <-
  melt_tri_down %>%
  na.omit() %>%
  ggplot(aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient2(
    limit = c(-1, 1),
    high = "firebrick3",
    mid = "white",
    low = "navyblue",
    name = "Pearson \n correlation") +
  scale_y_discrete(position = "right") +
  labs(x = "", y = "") +
  theme_minimal() +
  theme(
    aspect.ratio = 1,
    axis.ticks = element_line(),
    axis.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = c(.1, .75)
  ) +
  guides(
    fill = guide_colourbar(barheight = 10)
  )

  ggsave(plot = cor_plot, "Figures/wheat_corrplot.png")

```


##### PCA
To reveal hidden structures in the population.

| prcomp() | name     | Description                                                                  |
|----------|----------|------------------------------------------------------------------------------|
| sdev 	   | sdev 	  | standard deviations of the principal components                              |
| rotation | loadings | matrix of variable loadings (columns are eigenvectors)                       |
| center 	 | center 	| variable means (means that were substracted)                                 |
| scale 	 | scale 	  | variable standard deviations (the scaling applied to each variable)          |
| x 	     | scores 	| coordinates of the individuals (observations) on the principal components.   |

```{r}
# using the eda_met data, after removing the NAs
# pca <- prcomp(eda_met, center = T, scale = T)
# pca
```

```{r}
# Merge datasets

met_data <- met_data  %>% as_tibble()
info_data <- info_data  %>% as_tibble()

b <- info_data %>%
  select(DNA_CODE, SPECIES, TYPE) %>%
  rename(ID = DNA_CODE)

a <- met_data %>%
  select(-BLK, -ROW) %>%
  arrange(ID)

# full dataset for the plot, here were also removed the NAs to keep the same number of rows of info_data and met_data
join_df <-
  full_join(a, b, by = "ID") %>%
  select(-PLOT, -COL) %>%
  na.omit() #how to select the filtered out NAs?

# which data are NAs?

full_join(a, b, by = "ID") %>%
  select(-PLOT, -COL) %>%
  mutate(NAs = is.na())
```

Perform SVD:
```{r}
# from the full joined data, select only the <int> and <dbl>  columns for the svd calculations.

pca_df <- join_df %>%
  select(DB:TGW)

# standardize data center around zero and scale around 1 unit variance (st.dev)
std_pca_data <- scale(pca_df)
# cov matrix
cov_mat <- cov(std_pca_data)
# singular value decomposition
svd_res <- svd(cov_mat)

svd_res

?base::svd()
```

We obtain the decomposition of the covariate matrix as:

$ X=U\Sigma V^{T} $

Where:

$[U]$ is the left singular vectors matrix of dimensions $n \times p$ as the number of variables ($p$) and observations ($n$). Each column is a vector $\vec{u}_{i \dots n}$ representing the directions of maximum variance in $X$-the original data set.

$[\Sigma]$ (or $D$) is the diagonal matrix, contain the singular values of the original data matrix. The singular values represent the maximum variance captured by each principal component. The values are arranged in descending order by importanceof each principal component.

$[V]$ is the right ingular vector matrix, containing the coefficients (loadings) of the original variables on the proncipal components. Each column contains the loadings of one principal component for each original variable. Dimensions of $V$ are $p \times p$, as $p$ the number of variables. Often $V$ is rapresented in the transposed form $V^T$ because the columns represent the loading of the original variables on the PCs.

```{r}
# singular values, left singular vectors (loadings), and right singular vectors (scores)
singular_values <- svd_res$d
loadings <- svd_res$v
scores <- std_pca_data %*% svd_res$u

# explained variance
tot_var <- sum(singular_values^2)
var_explained <- (singular_values^2) / tot_var
```
```{r}
#  loadings
head(loadings)
# scores
head(scores)
# explained variances
head(var_explained)
```

and plot scree plot, individuals and scores.
```{r}
n_PCs <- 1:length(var_explained)

exp_var_df <- tibble::tibble(PC = n_PCs) %>%
  mutate(exp_var = var_explained, exp_var_perc = round(exp_var * 100, 1))

plot_exp_var <-
  exp_var_df %>%
  ggplot(., aes(factor(PC), exp_var_perc)) +
  geom_col(alpha = .6, fill = "gray") +
  geom_point(size = 2) +
  geom_line(aes(x = PC)) +
  geom_text(aes(PC + 0.2, exp_var_perc + 2, label = exp_var_perc), angle = 0) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 67)) +
  scale_x_discrete(expand = c(0, 0)) +
  labs(x = "Dimension", y = "Explained variance (%)") +
  theme_classic() +
  theme(aspect.ratio = 1)


path <- "Figures/wheat_exp_var_agro_data.png"

ggsave(path, plot = plot_exp_var, width = 10, dpi = 120)
knitr::plot_crop(path)
```
Score plot of the individuals

```{r}
# metadata?
met_data %>% as_tibble()
summary(met_data)
# grouping and descriptive data of the individuals is not present in the `met_data` dataframe, thus we  need to merge it with the `info_data`, based on the columns `met_data$ID` and `info_data$DNA_CODE`
head(info_data)
# here there are collected descriptors as SPECIES and TYPE
```
```{r}
info_data <- info

info_data <- info_data %>%
  select(DNA_CODE:ncol(.)) %>%
  rename(ID = DNA_CODE)  %>%
  as_tibble()

met_data <- met %>% as_tibble()

pca_met_join <- met_data %>%
  select(ID:ncol(met_data)) %>%
  full_join(info_data, by = "ID") %>%
  na.omit()
```
```{r}
# Join PCA scores with metadata

scores_df <- scores %>% as_tibble()

pca_met_join <- cbind(ID = met_data$ID, scores_df)
pca_met_join <- full_join(pca_met_join, info_data, by = "ID")
```

```{r}
# plot individuals
ggplot(scores_df, aes(x = scores_df[,1], y = scores_df[,2])) +
  geom_point(aes(color = eda_met_join)) +
  labs(x = paste0("PC1 (", round(var_explained[1] * 100, 2), "%)"),
       y = paste0("PC2 (", round(var_explained[2] * 100, 2), "%)")) +
  ggtitle("PCA Plot of Individuals (PC1 vs PC2)") +
    theme_minimal() +
    theme(aspect.ratio = 1)

```

TEST
```{r}
pca_data <- met_data %>%
  select(DB:ncol(met_data)) %>%
  na.omit() %>%
  as_tibble()

std_pca_data <- scale(pca_data)
cov_mat <- cov(std_pca_data)
svd_res <- svd(cov_mat)
scores <- std_pca_data %*% svd_res$u

scores <- as_tibble(scores)

# Join PCA scores with metadata
head(pca_met_join) <- cbind(ID = met_data$ID, scores)
pca_met_join <- full_join(pca_met_join, info_data, by = "ID")

# Plot PCA scores
ggplot(pca_met_join, aes(x = PC1, y = PC2, color = SPECIES)) +
  geom_point() +
  labs(x = paste0("PC1 (", round(var_explained[1] * 100, 2), "%)"),
       y = paste0("PC2 (", round(var_explained[2] * 100, 2), "%)")) +
  ggtitle("PCA Plot of Individuals (PC1 vs PC2)") +
  theme_minimal() +
  theme(aspect.ratio = 1)

dim(met_data)
dim(scores)
```